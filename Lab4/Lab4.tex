\documentclass[12pt, letterpaper, titlepage]{article}
\usepackage[utf8]{inputenc}

\usepackage{geometry}
\usepackage{color,graphicx,overpic,colortbl} 
\usepackage{fancyhdr}
\usepackage{amsmath,amsthm,amsfonts,amssymb}
\usepackage{mathtools}
\usepackage{hyperref}
\usepackage{multicol}
\usepackage{array}
\usepackage{float}
\usepackage{blindtext}
\usepackage{longtable}
\usepackage{scrextend}
\usepackage[font=small,labelfont=bf]{caption}
\usepackage{calc}
\usepackage{titlesec}
\usepackage{listings}
\usepackage[normalem]{ulem}
\usepackage{tabularx}
\usepackage{mathrsfs}
\usepackage{bookmark}
\usepackage{setspace}
\usepackage{ragged2e}
\usepackage{ltablex}
\usepackage{xurl}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{xparse}

\pgfplotsset{width=8cm,compat=1.15}\usepgfplotslibrary{patchplots}
\mathtoolsset{showonlyrefs}  
\allowdisplaybreaks

\definecolor{mycolor}{rgb}{0, 0, 0}

\geometry{top=2.54cm, left=2.54cm, right=2.54cm, bottom=2.54cm}
\setlength{\headheight}{20pt}
\setlength{\parskip}{0.3cm}
\setlength{\parindent}{1cm}

\pagestyle{fancy}
\fancyhf{}
\rhead{Lora Ma - 1570935}
\lhead{\textit{ECE 322 Lab 3}}
\rfoot{Page \thepage}

\begin{document} 
\singlespacing

\section{Introduction}
The purpose of this lab is to become familiar with white-box testing and rudimentary testing techniques such as unit testing. The goal of this lab was to give us experience with pairwise test case generation tools such as allpairspy and orthogonal tables to come up with test cases. The lab shows us how to use Python, Pycharm, the unittest testing framekwork, and allpairspy pairwise generation python tool as testing tools. We will learn white-box testing and pairwise testing. 

White-box testing focuses on testing the internal structure and implementation details of an application. This is the opposite of Black-box testing, a strategy we learned in a previous lab. In white-box testing, the tester needs to have a detailed understanding of the internal structure of the software being tested. Usually this means that the tester has direct access to the program's source code. 

We will also take a look at pairwise testing which allows us to consider all possible combinations of input variables. Pairwise testing allows us to efficiently create a set of test cases that cover all possible combinations of pairs of inputs. The Orthogonal Array Test Strategy (OATS) is a common strategy used to test the pair-wise interactions of variables. The python library allpairspy computationally calculates approximations to orthogonal arrays to generate pairwise test cases.

The first program is a program called mybisect. This program implements the well-known bisection algorithm in mathematics to find the root of any polynomial where $x=0$. The source code was then analyzed and test cases were generated for the program. A control flow graph was also generated for the program. For the second task, we completed a conceptual exercise to compare the use of orthogonal arrays to randomly generated combinations. Then we discussed the effectiveness of tests that were generated using the allpairspy estimation tool compared to the orthogonal arrays.

\section{Part One - Drone}
\subsection*{Q1}
Unit testing is a white-box testing technique. White-box testing focuses on testing the internal structure and implementation details of an application. A program may have several functions where each function needs to be thoroughly tested using unit tests to cover all scenarios. When a unit test fails, the tester knows which function is failing and the exact test that is failing. Through this, the tester can fix that specific case. Additionally, it is helpful for when developers build on top of their program. Usually programs are quite intertwined, so it is difficult to know how one change may affect the whole system. Unit tests give the developer ease of mind that their change has not destroyed the functionality of other areas of the program. 

\subsection*{Q2}
Code coverage describes how complete your set of test cases are in terms of how much of the program it actually is able to test. This is important for the developer to know because it gives the developer insight to how much of  their software is actually being tested. Statement coverage is where every statement in the code has to be executed at least once and branch coverage is where every branch in the code has to be executed at least once.

\subsection*{Q3}
Pairwise testing allows us to consider all possible combinations of input variables. Pairwise testing allows us to efficiently create a relatively small set of test cases that cover all possible combinations of pairs of inputs. While it doesn't catch all edge cases, it is effective at finding most bugs. It is able to cover cases that deal with one input or two interacting inputs. 

\section{Part One - Bisect}

\subsection*{Q1}
In task 1, the mybisect application was tested using White-box testing. mybisect implements a well-known bisection algorithm in mathematics to find the root of any polynomial where $x=0$. The algorithm implemented in mybisect is outlined as follows:
\begin{enumerate}
    \item Check if $a*b > 0$
    \item Calculate mid, the midpoint of the interval: $\text{mid} = \frac{a+b}{2}$
    \item Calculate the value at mid: $f(\text{mid})$
    \item Checks if $f(\text{mid})*f(a)$ is less than zero. If it is, $b$ = mid, otherwise $a = mid$
    \item If $|f(\text{mid})|$ is within the the tolerance, stop the program, otherwise repeat until you reach max iterations or you break
\end{enumerate}

\subsection*{Q2}
\begin{centering}
\includegraphics[scale=0.5]{Diagram1.png}
\end{centering}

\newpage
\subsection*{Q3}
\begin{centering}
    \begin{tabularx}{\textwidth}{|q|X|q|e|e|X|e|}
        \textbf{Test ID} & \textbf{Description} & \textbf{func} & \textbf{x1} & \textbf{x2} & \textbf{Expected} & \textbf{Pass} \\ \hline
        1 & Normal case & $x + 1$ & -10 & 10 & 0 & Y \\ \hline
        2 & Exception is thrown when f(x1) \textgreater 0 and f(x2) \textgreater 0 & $x^2+1$ & -10 & 10 & ValueError & Y \\ \hline
        3 & Exception is thrown when maximum iterations exceeded & $x$ & -1 & 1e10 & ValueError & Y \\ \hline
        4 & Default constructor (no args) & N/A & -10 & 10 & TypeError & Y \\ \hline
        5 & Custom tolerance (use tol = 10.0) & $x$ & -10 & 10 & 0 & Y \\ \hline
        6 & Custom max iterations (max it = 1000) & $x$ & -1 & 1e10 & 0 & Y \\ \hline
        7 & Custom tolerance \& max iterations (tol = 10.0, max it = 1000) & $x$ & -10 & 10 & 0 & Y \\ \hline
        8 & Tolerance getter & $x$ & N/A & N/A & tol = 1e-7 & Y \\ \hline
        9 & Tolerance setter (tol = 10.0) & $x$ & N/A & N/A & tol = 10.0 & Y \\ \hline
        10 & Max iterations getter & $x$ & N/A & N/A & max it = 50 & Y \\ \hline
        11 & Max iterations getter (max it = 500) & $x$ & N/A & N/A & max it = 5 & Y \\ \hline
    \end{tabularx}
\end{centering}
\subsection*{Q4}
\begin{enumerate}
    \item Statement coverage is relatively easy to attain, but requires quite a few test cases. Getters and setter had to both be called in order to obtain statement coverage for them. Despite this, this was the easiest to achieve.
    \item Branch coverage is not too difficult to attain, but requires many test cases to enter all branches. It is more work than statement coverage.
    \item The tests achieved full statement and branch coverage (outside of main)
    \item There were no errors discovered. If we had more tests, perhaps we would find some errors since coverage tests do not mean effective tests.
    \item Path testing would be extremely difficult. The number of paths is $n+1 \leq \text{\#Tests} \leq 2^n$ where $n$ indicates the number of branches. The number of tests we would need is enormous and it would be unreasonable to use path testing.
\end{enumerate}

\subsection*{Q5}
Test code file:
\begin{lstlisting}[language=Python, style=code_style]
    import unittest
    from mybisect import Polynomial
    from mybisect import MyBisect


    class TestMyBisect(unittest.TestCase):
        def test_normal(self):
            f = Polynomial(1, 1)
            b = MyBisect(f)
            result = b.run(-10, 10)
            self.assertAlmostEqual(0, f(result), None, None, b.tolerance)

        def test_pos(self):
            f = Polynomial(1, 0, 1)
            b = MyBisect(f)
            self.assertRaises(ValueError, b.run, -10, 10)

        def test_ex_max_iter(self):
            f = Polynomial(1, 0)
            b = MyBisect(f)
            self.assertRaises(ValueError, b.run, -1, 100000000000)

        def test_def_const(self):
            b = MyBisect()
            self.assertRaises(TypeError, b.run, -10, 10)

        def test_tol_const(self):
            f = Polynomial(1, 0)
            b = MyBisect(10.0, f)
            result = b.run(-10, 10)
            self.assertEqual(result, 0)

        def test_max_it_cons(self):
            f = Polynomial(1, 0)
            b = MyBisect(100, f)
            result = b.run(-1, 100000000000)
            self.assertAlmostEqual(0, f(result), None, None, b.tolerance)

        def test_tol_and_max_it_const(self):
            f = Polynomial(1, 0)
            b = MyBisect(10.0, 100, f)
            result = b.run(-1, 1)
            self.assertAlmostEqual(0, f(result), None, None, b.tolerance)

        def test_tol_getter(self):
            f = Polynomial(1, 0)
            b = MyBisect(f)
            self.assertEqual(b.tolerance, 0.000001)

        def test_tol_setter(self):
            f = Polynomial(1, 0)
            b = MyBisect(f)
            b.tolerance = 10.0
            self.assertEqual(b.tolerance, 10.0)

        def test_max_iter_getter(self):
            f = Polynomial(1, 0)
            b = MyBisect(f)
            self.assertEqual(b.maxIterations, 50)

        def test_max_iter_setter(self):
            f = Polynomial(1, 0)
            b = MyBisect(f)
            b.maxIterations = 5
            self.assertEqual(b.maxIterations, 5)


    if __name__ == "__main__":
        unittest.main()
\end{lstlisting}
\newpage
HTML coverage report:

\includegraphics[scale=0.7]{coverage.png}

\section{Part 2 - Pairwise}
\subsection*{Q1}
The following orthogonal array from https://www.york.ac.uk/depts/maths/tables/l9.gif is a close match.

\begin{centering}
\includegraphics[scale=0.7]{york.png}
\end{centering}

After reducing the numbers by 1 and removing the last column, we get the following table:

\begin{centering}
    \begin{tabularx}{\textwidth}{|X|X|X|X|}
        \caption{Test cases similar orthogonal array.} \\ \hline
        Test \# & A & B & C \\ \hline
        1 & 0 & 0 & 0 \\ \hline
        2 & 0 & 1 & 1 \\ \hline
        3 & 0 & 2 & 2 \\ \hline
        4 & 1 & 0 & 1 \\ \hline
        5 & 1 & 1 & 2 \\ \hline
        6 & 1 & 2 & 0 \\ \hline
        7 & 2 & 0 & 2 \\ \hline
        8 & 2 & 1 & 0 \\ \hline
        9 & 2 & 2 & 1 \\ \hline
    \end{tabularx}
\end{centering}

\subsection*{Q2}
To programmatically generate tests, we used allpairspy to generate pairwise test cases. The table is shown below:

\begin{centering}
    \begin{tabularx}{\textwidth}{|X|X|X|X|}
        \caption{Test cases generated using allpairspy} \\ \hline
        Test \# & A & B & C \\ \hline
        1 & 0 & 0 & 0 \\ \hline
        2 & 1 & 1 & 0 \\ \hline
        3 & 2 & 2 & 0 \\ \hline
        4 & 2 & 1 & 1 \\ \hline
        5 & 1 & 0 & 1 \\ \hline
        6 & 0 & 2 & 1 \\ \hline
        7 & 0 & 1 & 2 \\ \hline
        8 & 1 & 2 & 2 \\ \hline
        9 & 2 & 0 & 2 \\ \hline
    \end{tabularx}
    \end{centering}
\subsection*{Q3}
\begin{enumerate}
    \item Comparing the program to orthogonal arrays, they had the same amount of test cases. Generating the test cases using code was more simple than using the orthogonal array.
    \item Both tools were effective in generating test cases. They found the same number of test cases and where able to equally reduce the amount of test cases.
    \item Pairwise testing tests singular inputs or the interaction of two inputs within the program.
    \item Compared to combinational testing, pairwise testing significantly reduces the amount of tests. It is possible that combinational testing is more effective in reducing the amount of edge cases, but overall pairwise testing does a relatively good job for the amount of tests needed. Combinational testing can deal with interactions of more than two variables with eachother whereas pairwise can't. 
\end{enumerate}

\subsection*{Q4}
\begin{lstlisting}[language=Python, style=code_style]
    from allpairspy import AllPairs


    def getallpairspy(parameters):
    
        print("PAIRWISE:")
        for i, pairs in enumerate(AllPairs(parameters)):
            print("{:2d}: {}".format(i, pairs))
    
    def main():
        parameters = [
            [0, 1, 2],
            [0, 1, 2],
            [0, 1, 2],
        ]
    
    
        getallpairspy(parameters)
    if __name__ == "__main__":
        main()
\end{lstlisting}

\section{Conclusion and Discussion}
In this lab, we were introduced to the white-box testing strategy. We focused on control flow testing and coverage criterion. Specifically, statement coverage, branch coverage, condition coverage, and path coverage. Because we had the source code, we were able to make a control flow graph and test cases by inpsecting the source code. We were also able to form tests that would check for correctness of the program, but also check for branch and line coverage. Statement and branch coverage do not indicate good tests, but indicate lines or branches tested. This gives the developer a good idea of what has been tested. In the second part of the lab, we learned pairwise testing and used tools like allpairspy to help generate test cases. We found a similar orthogonal array and generated test cases. Then we used allpairspy to generate test cases. Doing this, we found that both methods were equally effective at generating and reducing test cases. We then discussed some pros and cons of pairwise testing where a con is that some edge cases may still occur when more than two inputs interact with eachother.

\end{document}